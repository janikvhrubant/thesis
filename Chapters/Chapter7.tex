\chapter{The Simulation Algorithm} % Main chapter title
\label{Chapter5} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}


In this chapter the implementation algorithm is presented. The algorithm takes
elements from the gQMCFFD algorithm from \cite{qmcXray2023} and adapts it to the
needs of this thesis. The algorithm is designed to simulate X-ray images
efficiently, including scattering effects and is specifically tailored to
analyze and compare the performance of different sampling methods.

\ac{ffd} is a method used to simulate X-ray images efficiently, particularly in the context of X-ray imaging systems. It is designed to handle multiple scatter orders and can be used either with Monte Carlo sequences or with Quasi-Monte Carlo (QMC) sequences for sampling the random variables involved in the simulation
%-------------------------------------------------------------------------------
%	SECTION 1
\section{Algorithm overview}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
%	SECTION 1
\section{Sub-Algorithms}
%-------------------------------------------------------------------------------
To structure the algirthms into the different physical effects, this section is
gathering highly relevant algirithms which are later orchestrated by the main
simulation algorithm.

\subsection{Photon Generation}
For the photon generation, two main properties for each photon do need to be
sampled:

\begin{itemize}
    \item The \emph{Photon Energy} which is sampled with one random variable
    from the spectrum.
    \item The \emph{Photon Direction} which is sampled with two random 
    variables uniformly in the cone of the beam with direction $d$ and angle
    $\alpha$. 
\end{itemize}

For the photon energy the spectrum of the X-ray tube is referenced with an array
of energies and another array with the according fluence.
These spectrum values are sampled with \emph{Spekpy} \cite{spekpy,poludniowski2021spekpy} for a X-ray tube with the following parameters:
\begin{itemize}
    \item \textbf{Tube Voltage:} 120 kV
    \item \textbf{Anode Material:} Tungsten
    \item \textbf{Filtration:} $0.4$ \si{\milli\meter} of Tin (Sn) and $0.1$ \si
    {\milli\meter} of Copper (Cu)
    \item \textbf{Target Angle:} 12.5°
\end{itemize}

The following algorithm samples the photon energy from the spectrum using
inverse transform sampling. The algorithm takes an array of energies and their
corresponding fluence values, normalizes the fluence to create a probability
density function (PDF), computes the cumulative distribution function (CDF)
and then uses a random variable to sample the photon energy based on the CDF.

\begin{algorithm}[H]
\caption{Photon Energy Sampling from Spectrum}
\begin{algorithmic}[1]
\Require Array of energies $E = [E_1, E_2, \dots, E_n]$ 
\Require Corresponding fluence values $\Phi = [\phi_1, \phi_2, \dots, \phi_n]$ 
\Require Number of samples $N$ 
\Require Random variable $u \sim \mathcal{U}(0, 1)$ \Ensure Sampled photon
energies $S = [s_1, s_2, \dots, s_N]$

\LineComment{Normalize fluence values:} \State $$T \gets \sum_{i=1}^{n} \phi_i$$
\State $$\text{PDF}[i] \gets \frac{\phi_i}{T}$$

\LineComment{Compute cumulative distribution function:} 
\State $$\text{CDF}[1] \gets \text{PDF}[1]$$ 
\For{$i = 2$ to $n$} 
\State $\text{CDF}[i] \gets \text{CDF}[i-1] + \text{PDF}[i]$ 
\EndFor

\LineComment{Note: $PDF[i]>0$ in the spectrum, therefore $\text{CDF}$ is
strictly increasing.}

\State Create interpolating function $\text{ InverseCDF}(u)$ from
$(\text{CDF}[i], E[i])$

\State \Return $\text{InverseCDF}(u)$

\end{algorithmic}
\end{algorithm}

Further the photon direction is sampled uniformly in the cone with angle
$\alpha$ of the beam of the X-ray tube with spherical direction $\vec{d}$.
Therefore two random variables are required $u_1, u_2 \sim \mathcal{U}(0, 1)$.

\begin{algorithm}[H]
\caption{Uniform Direction Sampling Within a Cone}
\begin{algorithmic}[1]
\Require Cone angle $\alpha$
\Require Unit beam direction vector $\vec{d} = (d_1, d_2, d_3)$
\Require Random variables $u_1, u_2 \sim \mathcal{U}(0,1)$
\Ensure Sampled direction vector $\vec{v}$ uniformly within cone around
$\vec{d}$

\LineComment{Calculate angles according to samples}

\State $\theta \gets \arccos(1 - u_1 (1 - \cos \alpha))$ \Comment{Polar angle}
\State $\phi \gets 2\pi u_2$ \Comment{Azimuthal angle}

\LineComment{Calculate local direction vector in spherical coordinates}

\State $$\vec{v}_{\text{local}} \gets 
\begin{pmatrix}
\sin\theta \cos\phi \\
\sin\theta \sin\phi \\
\cos\theta \end{pmatrix}$$

\LineComment{Orthonormal basis construction (Gram-Schmidt)}
\If{$|d_3| < 0.999$}
    \State $\vec{a} \gets (0, 0, 1)$
\Else
    \State $\vec{a} \gets (1, 0, 0)$
\EndIf
\State $\vec{u} \gets \frac{\vec{a} \times \vec{d}}{\|\vec{a} \times \vec{d}\|}$ \Comment{Orthogonal vector}
\State $\vec{v} \gets \vec{d} \times \vec{u}$ \Comment{Complete right-handed basis}

\LineComment{Rotate local vector into global coordinates}
\State $\vec{v}_{\text{global}} \gets \vec{u} (\vec{v}_{\text{local}})_x + \vec{v} (\vec{v}_{\text{local}})_y + \vec{d} (\vec{v}_{\text{local}})_z$

\State \Return $\vec{v}_{\text{global}}$

\end{algorithmic}
\end{algorithm}









% \textcolor{red}{ab hier noch nur Platzhalter}

% In this section the gQMCFFD algorithm from \cite{qmcXray2023} is introduced. The gQMCFFD algorithm uses QMC methods to simulate an X-ray image efficiently including scattering effects. The algorithm is designed to handle multiple scatter orders and utilizes 
% In this section the Algorithm~\ref{alg:gQMCFFD} from \cite{qmcXray2023} is presented. The \ac{qmc}-Method is used to simulate the X-ray image. Therefore the algorithm is used 
% The following pseudoalgorithm outlines the process of simulating X-ray photon transport using Quasi-Monte Carlo (QMC) methods. The algorithm generates a sequence of QMC samples to determine the initial positions and directions of photons, simulates their transport through a defined geometry, and records the results of interactions with materials. By that many other algorithms are used such als the \ac{rita} algorithm.
% \begin{algorithm}{gQMCFFD}
% \caption{gQMCFFD: X-ray Scatter Simulation (Part 1)}
% \label{alg:gQMCFFD}
% \begin{algorithmic}[1]
% \State \textbf{Input:} Max. scatter order $N$, phantom geometry $\mathcal{P}$, energy spectrum $\phi$, beam angle $\alpha$, set of detector pixels $\mathcal{G}=\{G_1, ..., G_s\}$, QMC point $u^j \in [0,1]^{4N}$, step size $\Delta s$
% \vspace{.25cm}

% \State \textbf{Initialize photon using } $u^j_1, u^j_2, u^j_3$:
% \begin{itemize}
%     \item energy $E_0 \sim \phi(E)$ by inverse transform sampling with $u^j_1$
%     \item direction $\vec{\omega}_0$ within cone angle $\alpha$ using $u^j_2, u^j_3$
%     \item weight $W_0 = I_0(\vec{\omega}_0) = 1$
%     \item escape probability $p_0 = 0$ \textcolor{red}{TODO: ist das richtig initialisiert?}
%     \end{itemize}
%     \State Compute entry point: find smallest $t_0$ s.t. $A_0 = S + t_0 \cdot \vec{\omega}_0 \in \partial\mathcal{P}$

% \vspace{.25cm}
% \State Initialize: $f_{n,k} = 0$ for all $D_k \in \mathcal{G}$

% \For{$i = 1$ to $N$} \State $t_i\gets\Delta s$ \Comment{Initialize path length}
%     \State$A_i \gets A_{i-1} + t_i \cdot \vec{\omega}_{i-1}$ \Comment{Initialize
%     position} \LineComment{
%     \parbox[t]{\dimexpr\linewidth-\algorithmicindent}{Sample free path length
%     $t_i$ with $u^j_{4i}$}}
    
%     \While{$A_{i} \in \mathcal{P}$ \textbf{and} $\int\limits_0^{t_i}
%     \mu_{\text{tot}}(A_{i-1} + s\vec{\omega}_{i-1}, E_{i-1}) ds < -\ln{\big(1 -
%     (1 - p_{i-1}) u^j_{4i} \big)}$} \State $t_i \gets t_i + \Delta s$
%     \Comment{Update path length} \State $A_i \gets A_{i-1} + t_i \cdot
%     \vec{\omega}_{i-1}$ \Comment{Update position} \EndWhile
    
%     \LineComment{Sample interaction type}
%     \If{$\mu_{\text{tot}}(A_i, E_i) \cdot u^j_{4i+3} < \mu_{\text{comp}}(A_i, E_i)$}

%         \State $\delta^i=0$ $\to$ \textbf{Compton Scattering}
%         \State $p_{y_0}$ gemäß Gleichung (5)
%         \State $\vec{\omega}_{i} \gets \text{comptonDirectionSampling}(E_{i-1}, \vec{\omega}_{i-1}, u^j_{4i+1}, u^j_{4i+2})$

%         \ElsIf{$\mu_{\text{comp}}(A_i, E_i) \leq \mu_{\text{tot}}(A_i, E_i)
%         \cdot u^j_{4i+3} < \mu_{\text{comp}}(A_i, E_i) + \mu_{\text{ray}}(A_i,
%         E_i)$}
        
%         \State $\delta^i=1$ $\to$ \textbf{Rayleigh Scattering} \State
%         $p_{y_1}$ gemäß Gleichung (6)

%         \Else 
%             \State \textbf{Photoelectric Absorption} $\to$ \textbf{break}
%     \EndIf
%     \State Sample new direction $\vec{\omega}_i$ using RITA using randoms $u^j_{4i+1}, u^j_{4i+2}$
%     \State \textcolor{red}{TODO: herausfinden, wie neue Energie berechnet wird}
%     \State Compute escape probability along $\vec{\omega}_{i-1}$:
%     $$p_{i-1} = \exp\left(-\int_0^{c_{i-1}} \mu_{\text{tot}}(A_{i-1} + s\vec{\omega}_{i-1}, E_{i-1}) ds\right)$$
    
%     \State Update weight: $W_i = W_{i-1} \cdot (1 - p_{i-1})$

%     \For{each detector pixel $D_j \in \mathcal{G}$}
%         \State Determine forced direction $\vec{\omega}_{i,j}$ from $A_i \to D_j$
%         \State Compute transmission factor:
%         \[
%         T_{i,j} = \exp\left(-\int_0^{b_{i,j}} \mu_{\text{tot}}(A_i + s\vec{\omega}_{i,j}, E_i) ds\right)
%         \]
%         \State Compute directional scatter PDF: $p^y(A_i, E_{i-1} \rightarrow E_i, \vec{\omega}_{i-1} \rightarrow \vec{\omega}_{i,j})$
%         \State Update scatter contribution:
%         \[
%         f_{n,j} \mathrel{+}= W_i \cdot p^y \cdot T_{i,j}
%         \]
%     \EndFor

% \EndFor

% \algstore{myalg}
% \end{algorithmic}
% \end{algorithm}

% \begin{algorithm}
% \caption{gQMCFFD: X-ray Scatter Simulation (Part 2)}
% \begin{algorithmic}[1]
% \algrestore{myalg}

% \vspace{.25cm}
% \State \textbf{Primary intensity (if unscattered):}
% \For{each detector pixel $D_j \in \mathcal{G}$}
%     \State Determine direct line $\vec{\omega}_{0,j}$ from $A_0$ to $D_j$
%     \State Compute:
%     \[
%     T_{0,j} = \exp\left(-\int_0^{b_{0,j}} \mu_{\text{tot}}(A_0 + s\vec{\omega}_{0,j}, E_0) ds\right)
%     \]
%     \State Add primary contribution:
%     \[
%     f_{n,j} \mathrel{+}= W_0 \cdot T_{0,j}
%     \]
% \EndFor

% \State \textbf{Output:} $f_{n,j}$ for each detector pixel $D_j \in \mathcal{G}$

% \end{algorithmic}
% \end{algorithm}